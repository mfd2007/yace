import Component from '../lib/component.js';
import TextArea from './textarea.js';
import TextInput from './textinput.js';
import ComboInput from './comboinput.js';
import store from '../store/index.js';
import * as ProductDatabase from '../lib/productdatabase.js';

export default class RemediationsList extends Component {
    
    vulnerabilityId = "";
    
    // Pass our store instance and the HTML element up to the parent Component
    constructor(selector, vulnerabilityId) {
        super({
            store,
            element: document.querySelector(selector)
        });
        this.vulnerabilityId = vulnerabilityId;
    }

    /**
     * React to state changes and render the component's HTML
     *
     * @returns {void}
     */
    render() {
        let self = this;

        // If there are no items to show, render a little status instead
        if((store.state.csaf?.vulnerabilities == undefined) ||
           (store.state.csaf?.vulnerabilities.length < this.vulnerabilityId) ||
           (store.state.csaf?.vulnerabilities[this.vulnerabilityId].remediations == undefined))
        {
          self.element.innerHTML = `
            <ul class="w3-ul">
              <li><h3>Remediations</h3></li>
              <li>
                <button id="add_vul_remediations" class="w3-button w3-block w3-green">Add remediation</button>
              </li>
            </ul>
         `;
        }else {
        // Loop the items and generate a list of elements
          self.element.innerHTML = `
            <ul class="w3-ul">
              <li><h3>Remediations</h3></li>
              ${store.state.csaf?.vulnerabilities[this.vulnerabilityId].remediations.map((remediationsItem, index) => {
                return `
                  <div class="w3-panel w3-leftbar">
                    <div class="w3-row">
                      <div class="w3-col w3-right" style="width:50px">
                        <button id="remove_remediations" class="w3-button  w3-pale-red" aria-label="Delete this item">&times</button>
                      </div>
                      <div class="w3-rest w3-container">
                        <div id="vulnerabilities.${this.vulnerabilityId}.remediations.${index}.category"></div>
                        <div id="vulnerabilities.${this.vulnerabilityId}.remediations.${index}.details"></div>
                        <div id="vulnerabilities.${this.vulnerabilityId}.remediations.${index}.url"></div>
                        <div> <label for="vulnerabilities.${this.vulnerabilityId}.remediations.${index}.product_ids">Select applicable products</label>
                        <select id="vulnerabilities.${this.vulnerabilityId}.remediations.${index}.product_ids" class="w3-select w3-border yace-remediation-products" data-vulnerabilityid="${this.vulnerabilityId}" data-remediationid="${index}" required multiple>
                              ${ProductDatabase.getProductFullNames(store.state.csaf).map(item => {
                                const vulnerabilityItem = store.state.csaf?.vulnerabilities[this.vulnerabilityId];
                                return `
                                  <option value="${item.product_id}" data-productid="${item.product_id}" ${(vulnerabilityItem?.remediations[index].product_ids != undefined && vulnerabilityItem?.remediations[index].product_ids.includes(item.product_id))?'selected':''}>${item.name}</option>
                                `
                              }).join('')}
                              </select>
                          </div>
                      </div>
                    </div>
                  </div>
                `
              }).join('')}
              <button id="add_remediations" class="w3-button w3-block w3-green">Add remediations</button>
            `;
            store.state.csaf?.vulnerabilities[this.vulnerabilityId].remediations.forEach((remediationsItem, index) => {
              let remediationCombo = new ComboInput(
                "#vulnerabilities\\."+this.vulnerabilityId+"\\.remediations\\."+index+"\\.category", 
                "Category", 
                "vulnerabilities."+this.vulnerabilityId+".remediations."+index+".category", 
                [
                  {value:"vendor_fix", label:"Vendor fix"},
                  {value:"mitigation", label:"Mitigation"},
                  {value:"workaround", label:"Workaround"},
                  {value:"none_available", label:"None available"},
                  {value:"no_fix_planned", label:"No fix planned"}],
                true);
              remediationCombo.render();
              let remediationDetails = new TextArea("#vulnerabilities\\."+this.vulnerabilityId+"\\.remediations\\."+index+"\\.details", "Details", "vulnerabilities."+this.vulnerabilityId+".remediations."+index+ ".details", true, "");
              remediationDetails.render();
              let remediationUrl = new TextInput("#vulnerabilities\\."+this.vulnerabilityId+"\\.remediations\\."+index+"\\.url", "Url", "vulnerabilities."+this.vulnerabilityId+".remediations."+index+".url", false, "https://");
              remediationUrl.render();
            });
        }
        // Add a submit event listener to the form and prevent it from posting back
        self.element.querySelectorAll('#add_vul_remediations').forEach((button) => {
          button.addEventListener('click', () => {
            store.dispatch('addVulRemediations', {"vulId": this.vulnerabilityId});
          });
        });
        
        // Find all the buttons in the list and when they are clicked, we dispatch a 
        // `clearItem` action which we pass the current item's index to
        self.element.querySelectorAll('#remove_vul_remediations').forEach((button, index) => {
            button.addEventListener('click', () => {
                store.dispatch('removeVulRemediations', { "vulId": this.vulnerabilityId, "index": index });
            });
        });
        
        self.element.querySelectorAll("input[type=\"text\"]").forEach((element) => {
            element.addEventListener('change', () => {
                store.dispatch('setItem', { path: element.id, value: element.value});
            });
        });
        
        self.element.querySelectorAll("select.yace-remediations").forEach((element) => {
            element.addEventListener('change', () => {
                store.dispatch('setItem', { path: element.id, value: element.value});
            });
        });

        self.element.querySelectorAll("select.yace-remediation-products").forEach((element) => {
          element.addEventListener('change', () => {
              store.dispatch('setRemediationProduct', { "path": element.id, "productIds": Array.from(element.selectedOptions, x => x.value), "vulnerabilityId": element.dataset.vulnerabilityid, "remediationId": element.dataset.remediationid});
          });
      });

    }
};
