import Component from '../lib/component.js';
import TextInputVector from './textinputVector.js';
import store from '../store/index.js';
import * as ProductDatabase from '../lib/productdatabase.js';

export default class ScoresList extends Component {
    
    vulnerabilityId = "";
    
    // Pass our store instance and the HTML element up to the parent Component
    constructor(selector, vulnerabilityId) {
        super({
            store,
            element: document.querySelector(selector)
        });
        this.vulnerabilityId = vulnerabilityId;
    }

    /**
     * React to state changes and render the component's HTML
     *
     * @returns {void}
     */
    render() {
        let self = this;

        // If there are no items to show, render a little status instead
        if((store.state.csaf?.vulnerabilities == undefined) ||
           (store.state.csaf?.vulnerabilities.length < this.vulnerabilityId) ||
           (store.state.csaf?.vulnerabilities[this.vulnerabilityId].scores == undefined))
        {
          self.element.innerHTML = `
            <ul class="w3-ul">
              <li><h3>Scores</h3></li>
              <li>
                <button id="add_vul_scores" class="w3-button w3-block w3-green">Add score</button>
              </li>
            </ul>
         `;
        }else {
        // Loop the items and generate a list of elements
          self.element.innerHTML = `
            <ul class="w3-ul">
              <li><h3>Scores</h3></li>
              ${store.state.csaf?.vulnerabilities[this.vulnerabilityId].scores.map((scoresItem, index) => {
                return `
                  <div class="w3-panel w3-leftbar">
                    <div class="w3-row">
                      <div class="w3-col w3-right" style="width:50px">
                        <button id="remove_scores" class="w3-button  w3-pale-red" aria-label="Delete this item">&times</button>
                      </div>
                      <div class="w3-rest w3-container">
                        <div id="vulnerabilities.${this.vulnerabilityId}.scores.${index}.cvss_v3.vectorString" class="yace-score-values"></div>
                        <div> <label>Base score: ${scoresItem.cvss_v3?.baseScore}</label>
                        <div> <label>Base Severity: ${scoresItem.cvss_v3?.baseSeverity}</label>
                        <div> <label for="vulnerabilities.${this.vulnerabilityId}.scores.${index}.product_ids">Select applicable products</label>
                        <select id="vulnerabilities.${this.vulnerabilityId}.scores.${index}.product_ids" class="w3-select w3-border yace-score-products" data-vulnerabilityid="${this.vulnerabilityId}" data-scoreid="${index}" required multiple>
                              ${ProductDatabase.getProductFullNames(store.state.csaf).map(item => {
                                const vulnerabilityItem = store.state.csaf?.vulnerabilities[this.vulnerabilityId];
                                return `
                                  <option value="${item.product_id}" data-productid="${item.product_id}" ${(vulnerabilityItem?.scores[index].product_ids != undefined && vulnerabilityItem?.scores[index].product_ids.includes(item.product_id))?'selected':''}>${item.name}</option>
                                `
                              }).join('')}
                              </select>
                          </div>
                      </div>
                      </div>
                    </div>
                  </div>
                `
              }).join('')}
              <button id="add_scores" class="w3-button w3-block w3-green">Add scores</button>
            `;
            store.state.csaf?.vulnerabilities[this.vulnerabilityId].scores.forEach((scoresItem, index) => {
              let scoreVectorString = new TextInputVector("#vulnerabilities\\."+this.vulnerabilityId+"\\.scores\\."+index+"\\.cvss_v3\\.vectorString", "CVSS 3.1 Vector", "vulnerabilities."+this.vulnerabilityId+".scores."+index+".cvss_v3.vectorString", true, "^CVSS:3.1/((AV:[NALP]|AC:[LH]|PR:[NLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])/)*(AV:[NALP]|AC:[LH]|PR:[NLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])$");
              scoreVectorString.render();
            });
        }
        // Add a submit event listener to the form and prevent it from posting back
        self.element.querySelectorAll('#add_vul_scores').forEach((button) => {
          button.addEventListener('click', () => {
            store.dispatch('addVulScores', {"vulId": this.vulnerabilityId});
          });
        });
        
        // Find all the buttons in the list and when they are clicked, we dispatch a 
        // `clearItem` action which we pass the current item's index to
        self.element.querySelectorAll('#remove_vul_scores').forEach((button, index) => {
            button.addEventListener('click', () => {
                store.dispatch('removeVulScores', { "vulId": this.vulnerabilityId, "index": index });
            });
        });

        self.element.querySelectorAll("select.yace-score-products").forEach((element) => {
          element.addEventListener('change', () => {
              store.dispatch('setScoreProduct', { "path": element.id, "productIds": Array.from(element.selectedOptions, x => x.value), "vulnerabilityId": element.dataset.vulnerabilityid, "scoreId": element.dataset.scoreid});
          });
      });

    }
};
